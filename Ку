# %% [markdown]
# Объявление бибилиотек и физические параметры тележки с маятником 

# %%
import numpy as np
import sympy
import scipy
import math
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from scipy.signal import tf2ss
import control as ct



M = 0.4
m = 0.2    
l = 0.25   
g = 9.8   
f = 0.0   



# %%


# %% [markdown]
# Описание системы в форме Коши

# %%
def po_koshi(y, t):
    theta, dtheta, x, dx = y
    sin_theta = math.sin(theta)
    cos_theta = math.cos(theta)
    
    denominator = (M + m)*l - m*l*cos_theta**2
    
    ddtheta = ((M + m)*g*sin_theta - m*l*dtheta**2*sin_theta*cos_theta - f*cos_theta) / denominator
    ddx = (m*l**2*dtheta**2*sin_theta + l*f - m*g*l*sin_theta*cos_theta) / denominator
    
    return [dtheta, ddtheta, dx, ddx]

def model(
        theta0, 
        dtheta0, 
        ts=10, nt=0.1, x0 = 0.0, dx0 = 0.0
        ):
 
    initial_conditions = [theta0, dtheta0, x0,dx0]
    t = np.arange(0, ts, nt)
    sol = odeint(po_koshi, initial_conditions, t)
    return sol

# %% [markdown]
# Построение фазового портрета с нулевыми условиями по положению и скорости каретки в собственном базисе

# %%
def calcODE(theta0, dtheta0, ts=10, nt=101):
    
    x0 = 0.0   
    dx0 = 0.0  
    
    initial_conditions = [theta0, dtheta0, x0, dx0]
    t = np.linspace(0, ts, nt)  
    sol = odeint(po_koshi, initial_conditions, t)
    return sol

def drawPhasePortrait(deltaTheta=0.5, deltaDtheta=0.5, 
                     startTheta=-np.pi, stopTheta=np.pi, 
                     startDtheta=-5, stopDtheta=5, 
                     ts=10, nt=101,
                     xlim=None, ylim=None):
    plt.figure(figsize=(10, 6))
    
  
    startTheta = np.radians(startTheta)
    stopTheta = np.radians(stopTheta)
    deltaTheta = np.radians(deltaTheta)
    
    for theta0 in np.arange(startTheta, stopTheta, deltaTheta):
        for dtheta0 in np.arange(startDtheta, stopDtheta, deltaDtheta):
            sol = calcODE(theta0, dtheta0, ts, nt)
            plt.plot(sol[:, 0], sol[:, 1], 'b', alpha=0.5)  
    
    plt.xlabel(' θ')
    plt.ylabel('dθ/dе')
    plt.title(' dθ/dt')
    plt.grid()
    
    if xlim: plt.xlim(xlim)
    if ylim: plt.ylim(ylim)
    

    
    plt.show()


drawPhasePortrait(deltaTheta=15, deltaDtheta=0.5, 
                 startTheta=-180, stopTheta=180,
                 startDtheta=-3, stopDtheta=3,
                 ts=5, nt=1000,
                 xlim=[-3*np.pi, 3*np.pi], ylim=[-20, 20])

# %% [markdown]
# Линерализация диф уравнений, ФПС

# %% [markdown]
# ![{85FAB86E-7CE9-43DE-B64E-9F243DE8D163}.png](attachment:{85FAB86E-7CE9-43DE-B64E-9F243DE8D163}.png)

# %%
A = np.array([
    [0, 1, 0, 0],
    [(M+m)*g/(l*M), 0, 0, 0],
    [0, 0, 0, 1],
    [-m*g/M, 0, 0, 0]
])

B = np.array([[0], [-1/(l*M)], [0], [1/M]])
C_x = np.array([[0, 0, 1, 0]])
C_theta = np.array([[1, 0, 0, 0]])
D = np.array([[0]])
sys = ct.ss(A, B, C_x, D)

# %% [markdown]
# Построение матриц наблюдаемости и управляемости через передачу тета

# %%
Q = ct.obsv(A, C_theta)
W = ct.ctrb(A, B)
print("Матрица наблюдаемости:")
print(Q)
print(" ")
print("Матрица управляемости")
print(W)

# %% [markdown]
# Система не наблюдаема

# %% [markdown]
# Построение матриц наблюдаемости и управляемости через передачу x

# %%
Q = ct.obsv(A, C_x)
W = ct.ctrb(A, B)
print("Матрица наблюдаемости:")
print(Q)
print(" ")
print("Матрица управляемости")
print(W)
print(" ")
print("Ранг матрицы Q: ", np.linalg.matrix_rank(Q))
print("Ранг матрицы W: ", np.linalg.matrix_rank(W))

# %% [markdown]
# Система и управляема, и наблюдаема

# %% [markdown]
# Передаточная функция

# %%
G = ct.ss2tf(sys)
print("Передаточная функция G(s):")
G


# %% [markdown]
# Числитель и знаменатель передаточной функции

# %%
B_s = np.poly1d(G.num[0][0])
A_s=np.poly1d (G.den[0][0])

print("Числитель передаточной функции G(s):")
print(B_s)
print(" ")
print("\nЗнаменатель передаточной функции G(s):")
print(A_s)

# %% [markdown]
# Нахождение корней и полюсов

# %%
poles = ct.poles(sys)
zeros = ct.zeros(sys)


plt.figure(figsize=(8, 6))
plt.scatter(np.real(poles), np.imag(poles), marker='x', color='r', s=50)
plt.scatter(np.real(zeros), np.imag(zeros), marker='o', color='b', s=50)


plt.axhline(0, color='k', linestyle='-', linewidth=0.5)
plt.axvline(0, color='k', linestyle='-', linewidth=0.5)
plt.grid(True, linestyle='--', alpha=0.5)


plt.title('Карта полюсов и нулей', pad=20)
plt.xlabel('Re', labelpad=10)
plt.ylabel('Im', labelpad=10)
plt.legend()

# %% [markdown]
# Система не устойчива

# %% [markdown]
# ## Компьютерное моделирование линейной системы

# %%
stats = model(1, 0, 100, 0.1)
plt.figure(figsize=(8, 6))
plt.plot(stats[:, 0], label = 'Угол')
plt.plot(stats[:, 2], label = 'Положегие коретки')

plt.xlim(0, 30)

plt.legend(loc = 'upper right')


plt.title('Модуляция')

# %% [markdown]
# ##### Поведение объекта управления при  начальных условиях (1 0 0 0)

# %% [markdown]
# ## Синтез регулятора

# %%
s = sympy.symbols("s")
W_o = 1/M*(s**2-g/l)/(s**2*(s**2-(M+m)/(l*M)*g))
a_1, a_2, a_3, a_0 = sympy.symbols('a_1, a_2, a_3, a_0')
b_1, b_2, b_0 = sympy.symbols('b_1, b_2, b_0')
W_p = (a_3*s**3+a_2*s**2+a_1*s+a_0) /\
      (s**3+b_2*s**2+b_1*s+b_0)

print("Регулятор")
W_p


# %%
A_o = 1/M*(s**2-g/l)
B_o = (s**2*(s**2-(M+m)/(l*M)*g))
W_o = A_o/B_o
W_o

A_p = (a_3*s**3+a_2*s**2+a_1*s+a_0) 
B_p = (s**3+b_2*s**2+b_1*s+b_0)
W_p = A_p/B_p
W_p

A_s = B_o*A_p
B_s = A_o*A_p + B_o * B_p
W_s = sympy.together(A_s/B_s)
print("Эквивалентная передаточная функция с обратной связью")
W_s

# %%
eq = sympy.Eq(B_s,(s+1)**7)
eq

# %%
solv = sympy.solve(eq,[a_1,a_2,a_3,a_0,b_1,b_2,b_0])
solv

# %% [markdown]
# ## Моделирование нелинейной системы

# %% [markdown]
# #### Матрица параметров

# %%
W_p_num = np.array(sympy.Poly(A_p.subs(solv), s).all_coeffs()).astype(np.float32)
W_p_den = np.array(sympy.Poly(B_p.subs(solv), s).all_coeffs()).astype(np.float32)

# %%
A_, B_, C_, D_ = tf2ss(W_p_num, W_p_den)
reg = ct.ss(A_, B_, C_, D_)
reg

# %%
sys

# %%
sys_reg = ct.feedback(sys, reg)
sys_reg

# %%
def regul_sys(y, t):
    dy = sys_reg.A@y+sys_reg.B.reshape(-1)*f
    
    return dy

# %%
def model_reg(
        func, 
        theta0, 
        dtheta0, 
        ts=10, nt=0.1, x0 = 0.0, dx0 = 0.0
        ):
    initial_conditions = np.array([theta0, dtheta0, x0, dx0, 0, 0, 0])
    t = np.arange(0, ts, nt)
    sol = odeint(func, initial_conditions, t)
    return sol

stats = model_reg(regul_sys, 0.08, 0, 100, 0.1)

# %%
plt.figure(figsize=(8, 6))
plt.plot(stats[:, 0], label = 'Угол')
plt.plot(stats[:, 2], label = 'Положегие коретки')



plt.legend(loc = 'upper right')
plt.xlim(0,200)
plt.title('Модуляция')
plt.show()

# %% [markdown]
# ## Синтез системы стабилизации перевернутого маятника на каретке методами пространства состояний
# 

# %% [markdown]
# ### Линерализация модели

# %%
print("A =", A)
print("B =", B)
print("C =", C_x)
print("D =", D)

# %% [markdown]
# #### Синтез регулятора

# %%
p = np.array ([-1, -2, -4, -7])
W = ct.ctrb(A, B)
print("Ранг матрицы управляемости =", np.linalg.matrix_rank(W))

# %%
K = ct.place(A, B, p)
print("Матрица обратной связи K =", K)

# %%
A_closed = A - B @ K
print("Матрица замкнутой системы A_closed =", )
A_closed

# %%
p_closed = np.linalg.eigvals(A_closed)
print("Полюса замкнутой системы =", ) 
p_closed

# %% [markdown]
# #### Синтез наблюдатедя

# %%
p_L = 5 * p

# %%
Q = ct.obsv(A, C_x)
print("Ранг матрицы наблюдаемости:", np.linalg.matrix_rank(Q))

# %% [markdown]
# Система наблюдаема

# %%
L = ct.place(A.T, C_x.T, p_L).T
print("Матрица наблюдателя L:\n", L)

# %% [markdown]
# ### Динамический регулятор

# %%
def dynamic_reg(A, B, C, K, L):

    
    Ar = A - B @ K - L @ C
    Br = L
    Cr = -K
    Dr = np.zeros((K.shape[0], C.shape[0]))
    
    return Ar, Br, Cr, Dr

# %%

Ar, Br, Cr, Dr = dynamic_reg(A, B, C_x, K, L)
regulator = ct.ss(Ar, Br, Cr, Dr)

print("Матрицы динамического регулятора:")
print("Ar =\n", Ar)
print("Br =\n", Br)
print("Cr =\n", Cr)
print("Dr =\n", Dr)


# %% [markdown]
# ### Проверка устойчивости регулятора

# %% [markdown]
# #### Передаточная функция

# %%
regulator_tf = ct.ss2tf(regulator)
print("Передаточная функция регулятора:")
regulator_tf

# %% [markdown]
# #### Корни

# %%
regulator_poles = np.linalg.eigvals(Ar)

print("Собственные значения матрицы регулятора Ar:")
regulator_poles

# %%
plt.figure(figsize=(8, 6))
plt.scatter(np.real(regulator_poles), np.imag(regulator_poles), marker='x', color='r', s=100)
plt.axhline(0, color='k', linestyle='-', linewidth=0.5)
plt.axvline(0, color='k', linestyle='-', linewidth=0.5)
plt.title('Карта полюсов динамического регулятора')
plt.xlabel('Re')
plt.ylabel('Im')
plt.grid(True)
plt.show()

# %% [markdown]
# ### Анализ системы с динамическим регулятором

# %% [markdown]
# #### Система с обратной связью с регулятором

# %%
closed_sys = ct.feedback(ct.ss(A, B, C_x, D), regulator_tf, sign=1)
poles = ct.poles(closed_sys)
poles

# %%

plt.scatter(np.real(poles), np.imag(poles), 
            marker='x', color='r', s=100)
plt.axhline(0, color='k', linestyle='-', linewidth=0.5)
plt.axvline(0, color='k', linestyle='-', linewidth=0.5)
plt.title('Полюса замкнутой системы с динамическим регулятором')
plt.xlabel('Re')
plt.ylabel('Im')
plt.xlim(-35,5)
plt.ylim(-1,1)
plt.grid(True)
plt.show()

# %%
regulator = ct.ss(Ar, Br, Cr, Dr)
plant = ct.ss(A, B, C_x, D)
def closed_loop_system(y, t):

    theta, dtheta, x, dx = y[:4]
    theta_est, dtheta_est, x_est, dx_est = y[4:8]
    
    y_meas = x
    
    u = -K @ np.array([theta_est, dtheta_est, x_est, dx_est])
    
    sin_theta = np.sin(theta)
    cos_theta = np.cos(theta)
    denominator = (M + m)*l - m*l*cos_theta**2
    ddtheta = ((M + m)*g*sin_theta - m*l*dtheta**2*sin_theta*cos_theta - u*cos_theta) / denominator
    ddx = (m*l**2*dtheta**2*sin_theta + l*u - m*g*l*sin_theta*cos_theta) / denominator
    

    dz = A @ np.array([theta_est, dtheta_est, x_est, dx_est]) + B.flatten()*u + L.flatten()*(y_meas - x_est)
    
    return [
        dtheta, ddtheta[0], dx, ddx[0],  
        dz[0], dz[1], dz[2], dz[3]       
    ]

# %%
def simulate_simple(theta0=0.03, ts=5, nt=0.01):
    x0 = np.array([theta0, 0, 0, 0])  
    z0 = np.zeros(4)                  
    y0 = np.concatenate([x0, z0])
    
    t = np.arange(0, ts, nt)
    sol = odeint(closed_loop_system, y0, t)
    
 
    plt.plot(t, sol[:, 0], label='Угол θ')
    plt.plot(t, sol[:, 2], label='Положение x')
    plt.xlim(0,5)
    plt.xlabel('Время')
    plt.ylabel('Состояния')
    plt.title('Реакция системы с регулятором')
    plt.legend()
    plt.grid(True)
    plt.show()
    
    return t, sol

t, results = simulate_simple(theta0=0.1, ts=5)

# %%
closed_sys


